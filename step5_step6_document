前回のドキュメント
与えられていた貪欲法の上で
①
 (step5_greedy_two_opts.pyの11から15行まで)
総距離を計算する関数total_distanceを定義して、
ツアー(eg.[0, 3, 2, 1])の巡回順序通りに前後二つのcityの距離を計算して足し、最後は総距離を返す。
②
(step5_greedy_two_opts.pyの38行から51行) 
2-opt法を使って、貪欲法の結果を改善する2_opt関数を定義します。
二重for文のループを使った部分的に巡回順序を逆にして、例えば[0,3,2,1]の１番目から３番目を逆にして[0,1,2,3]にする。
そして総距離を計算する関数を使って総距離が縮んだら新しい順序を際よする。

結果を見ると
Challenge 0 : Total distance = 3418.1015991327126
Challenge 1 : Total distance = 3832.2900939051992
Challenge 2 : Total distance = 5232.964923917401
Challenge 3 : Total distance = 9261.012772746048
Challenge 4 : Total distance = 11591.844674406604
Challenge 5 : Total distance = 22314.04512090243
Challenge6:ずっと実行していたが結果が出ない。
貪欲法のサンプルの０から５までの結果よりは少し良くなっています。
0: 3,418.10	
1: 3,832.29
2: 5,449.44	
3: 10,519.16	
4: 12,684.06	
5: 25,331.84	
		
------------------------------------------------------------------------------------------------------
今回のドキュメント（city=2084)
①my_insertion.py
前の2-opt法を実行する前にbest_insertion法を使って、初期解を改善したいと思いました。
結果は47000ぐらいになりました。

②my_sa.py
2-optなどは局所的に最適化しているので、悪化する解も一定確率で受け入れたいです。
焼きなまし法を2-opt法とかと合わせて使ってみました。
だがパラメータはうまく調整していないせいかなぜか結果があまり変わらなかったです。

③my_3opt.py
焼きなまし法をやめて、3-optを使いました貪欲法、2-opt法、3-opt法を組み合わせることによって総距離は46065.63になりました。

④LKH法
http://webhotel4.ruc.dk/~keld/research/LKH/
高速で総距離が短くなりました。
2048個のデータを使って実行時間は26秒、総距離は39248
8192個のデータを使って実行時間は25分、総距離は78058
